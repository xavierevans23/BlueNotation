/**
 * WebMidi.js v3.0.0-alpha.26
 * A JavaScript library to kickstart your MIDI projects
 * https://webmidijs.org
 * Build generated on November 25th, 2021.
 *
 * © Copyright 2015-2021, Jean-Philippe Côté.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

/* Version: 3.0.0-alpha.26 - November 25, 2021 21:31:49 */
!function (e) { "use strict"; class t { constructor(e = !1) { this.eventMap = {}, this.eventsSuspended = 1 == e } addListener(e, s, a = {}) { if ("string" == typeof e && e.length < 1 || e instanceof String && e.length < 1 || "string" != typeof e && !(e instanceof String) && e !== t.ANY_EVENT) throw TypeError("The 'event' parameter must be a string or EventEmitter.ANY_EVENT."); if ("function" != typeof s) throw TypeError("The callback must be a function."); let i = new n(e, this, s, a); return this.eventMap[e] || (this.eventMap[e] = []), a.prepend ? this.eventMap[e].unshift(i) : this.eventMap[e].push(i), i } addOneTimeListener(e, t, n = {}) { n.remaining = 1, this.addListener(e, t, n) } static get ANY_EVENT() { return Symbol.for("Any event") } hasListener(e, s) { return void 0 === e ? !!(this.eventMap[t.ANY_EVENT] && this.eventMap[t.ANY_EVENT].length > 0) || Object.entries(this.eventMap).some(([, e]) => e.length > 0) : !!this.eventMap[e] && !!(this.eventMap[e].length > 0) && (s instanceof n ? this.eventMap[e].filter(e => e === s).length > 0 : "function" == typeof s ? this.eventMap[e].filter(e => e.callback === s).length > 0 : null == s) } get eventNames() { return Object.keys(this.eventMap) } getListeners(e) { return this.eventMap[e] || [] } suspendEvent(e) { this.getListeners(e).forEach(e => { e.suspended = !0 }) } unsuspendEvent(e) { this.getListeners(e).forEach(e => { e.suspended = !1 }) } getListenerCount(e) { return this.getListeners(e).length } emit(e, ...n) { if ("string" != typeof e && !(e instanceof String)) throw TypeError("The 'event' parameter must be a string."); if (this.eventsSuspended) return; let s = [], a = this.eventMap[t.ANY_EVENT] || []; return this.eventMap[e] && (a = a.concat(this.eventMap[e])), a.forEach(e => { if (e.suspended) return; let t = [...n]; Array.isArray(e.arguments) && (t = t.concat(e.arguments)), e.remaining > 0 && (s.push(e.callback.apply(e.context, t)), e.count++), --e.remaining < 1 && e.remove() }), s } removeListener(e, t, n = {}) { if (void 0 === e) return void (this.eventMap = {}); if (!this.eventMap[e]) return; let s = this.eventMap[e].filter(e => t && e.callback !== t || n.remaining && n.remaining !== e.remaining || n.context && n.context !== e.context); s.length ? this.eventMap[e] = s : delete this.eventMap[e] } async waitFor(e, t = {}) { return t.duration = parseInt(t.duration), (isNaN(t.duration) || t.duration <= 0) && (t.duration = 1 / 0), new Promise((n, s) => { let a, i = this.addListener(e, () => { clearTimeout(a), n() }, { remaining: 1 }); t.duration !== 1 / 0 && (a = setTimeout(() => { i.remove(), s("The duration expired before the event was emitted.") }, t.duration)) }) } get eventCount() { return Object.keys(this.eventMap).length } } class n { constructor(e, n, s, a = {}) { if ("string" != typeof e && !(e instanceof String) && e !== t.ANY_EVENT) throw TypeError("The 'event' parameter must be a string or EventEmitter.ANY_EVENT."); if (!n) throw ReferenceError("The 'target' parameter is mandatory."); if ("function" != typeof s) throw TypeError("The 'callback' must be a function."); void 0 === a.arguments || Array.isArray(a.arguments) || (a.arguments = [a.arguments]), (a = Object.assign({ context: n, remaining: 1 / 0, arguments: void 0, duration: 1 / 0 }, a)).duration !== 1 / 0 && setTimeout(() => this.remove(), a.duration), this.arguments = a.arguments, this.callback = s, this.context = a.context, this.count = 0, this.event = e, this.remaining = parseInt(a.remaining) >= 1 ? parseInt(a.remaining) : 1 / 0, this.suspended = !1, this.target = n } remove() { this.target.removeListener(this.event, this.callback, { context: this.context, remaining: this.remaining }) } } class s { static get MIDI_CHANNEL_MESSAGES() { return { noteoff: 8, noteon: 9, keyaftertouch: 10, controlchange: 11, programchange: 12, channelaftertouch: 13, pitchbend: 14 } } static get MIDI_CHANNEL_NUMBERS() { return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16] } static get MIDI_CHANNEL_MODE_MESSAGES() { return { allsoundoff: 120, resetallcontrollers: 121, localcontrol: 122, allnotesoff: 123, omnimodeoff: 124, omnimodeon: 125, monomodeon: 126, polymodeon: 127 } } static get MIDI_CONTROL_CHANGE_MESSAGES() { return { bankselectcoarse: 0, modulationwheelcoarse: 1, breathcontrollercoarse: 2, controller3: 3, footcontrollercoarse: 4, portamentotimecoarse: 5, dataentrycoarse: 6, volumecoarse: 7, balancecoarse: 8, controller9: 9, pancoarse: 10, expressioncoarse: 11, effectcontrol1coarse: 12, effectcontrol2coarse: 13, controller14: 14, controller15: 15, generalpurposeslider1: 16, generalpurposeslider2: 17, generalpurposeslider3: 18, generalpurposeslider4: 19, controller20: 20, controller21: 21, controller22: 22, controller23: 23, controller24: 24, controller25: 25, controller26: 26, controller27: 27, controller28: 28, controller29: 29, controller30: 30, controller31: 31, bankselectfine: 32, modulationwheelfine: 33, breathcontrollerfine: 34, controller35: 35, footcontrollerfine: 36, portamentotimefine: 37, dataentryfine: 38, volumefine: 39, balancefine: 40, controller41: 41, panfine: 42, expressionfine: 43, effectcontrol1fine: 44, effectcontrol2fine: 45, controller46: 46, controller47: 47, controller48: 48, controller49: 49, controller50: 50, controller51: 51, controller52: 52, controller53: 53, controller54: 54, controller55: 55, controller56: 56, controller57: 57, controller58: 58, controller59: 59, controller60: 60, controller61: 61, controller62: 62, controller63: 63, holdpedal: 64, portamento: 65, sustenutopedal: 66, softpedal: 67, legatopedal: 68, hold2pedal: 69, soundvariation: 70, resonance: 71, soundreleasetime: 72, soundattacktime: 73, brightness: 74, soundcontrol6: 75, soundcontrol7: 76, soundcontrol8: 77, soundcontrol9: 78, soundcontrol10: 79, generalpurposebutton1: 80, generalpurposebutton2: 81, generalpurposebutton3: 82, generalpurposebutton4: 83, controller84: 84, controller85: 85, controller86: 86, controller87: 87, controller88: 88, controller89: 89, controller90: 90, reverblevel: 91, tremololevel: 92, choruslevel: 93, celestelevel: 94, phaserlevel: 95, databuttonincrement: 96, databuttondecrement: 97, nonregisteredparametercoarse: 98, nonregisteredparameterfine: 99, registeredparametercoarse: 100, registeredparameterfine: 101, controller102: 102, controller103: 103, controller104: 104, controller105: 105, controller106: 106, controller107: 107, controller108: 108, controller109: 109, controller110: 110, controller111: 111, controller112: 112, controller113: 113, controller114: 114, controller115: 115, controller116: 116, controller117: 117, controller118: 118, controller119: 119, allsoundoff: 120, resetallcontrollers: 121, localcontrol: 122, allnotesoff: 123, omnimodeoff: 124, omnimodeon: 125, monomodeon: 126, polymodeon: 127 } } static get MIDI_REGISTERED_PARAMETERS() { return { pitchbendrange: [0, 0], channelfinetuning: [0, 1], channelcoarsetuning: [0, 2], tuningprogram: [0, 3], tuningbank: [0, 4], modulationrange: [0, 5], azimuthangle: [61, 0], elevationangle: [61, 1], gain: [61, 2], distanceratio: [61, 3], maximumdistance: [61, 4], maximumdistancegain: [61, 5], referencedistanceratio: [61, 6], panspreadangle: [61, 7], rollangle: [61, 8] } } static get MIDI_SYSTEM_MESSAGES() { return { sysex: 240, timecode: 241, songposition: 242, songselect: 243, tunerequest: 246, tuningrequest: 246, sysexend: 247, clock: 248, start: 250, continue: 251, stop: 252, activesensing: 254, reset: 255, midimessage: 0, unknownsystemmessage: -1 } } } class a { constructor(e, t = {}) { this.duration = u.defaults.note.duration, this.attack = u.defaults.note.attack, this.release = u.defaults.note.release, void 0 != t.duration && (this.duration = t.duration), void 0 != t.attack && (this.attack = t.attack), void 0 != t.rawAttack && (this.attack = i.from7bitToFloat(t.rawAttack)), void 0 != t.release && (this.release = t.release), void 0 != t.rawRelease && (this.release = i.from7bitToFloat(t.rawRelease)), Number.isInteger(e) ? this.identifier = i.toNoteIdentifier(e) : this.identifier = e } get identifier() { return this._name + (this._accidental || "") + this._octave } set identifier(e) { let t = i.getNoteDetails(e); if (u.validation && !e) throw Error("Invalid note identifier"); this._name = t.name, this._accidental = t.accidental, this._octave = t.octave } get name() { return this._name } set name(e) { if (u.validation && !["C", "D", "E", "F", "G", "A", "B"].includes(e = e.toUpperCase())) throw Error("Invalid name value"); this._name = e } get accidental() { return this._accidental } set accidental(e) { if (u.validation && !["#", "##", "b", "bb"].includes(e = e.toLowerCase())) throw Error("Invalid accidental value"); this._accidental = e } get octave() { return this._octave } set octave(e) { if (u.validation && isNaN(e = parseInt(e))) throw Error("Invalid octave value"); this._octave = e } get duration() { return this._duration } set duration(e) { if (u.validation && (isNaN(e = parseFloat(e)) || null === e || e < 0)) throw RangeError("Invalid duration value."); this._duration = e } get attack() { return this._attack } set attack(e) { if (u.validation && (isNaN(e = parseFloat(e)) || !(e >= 0 && e <= 1))) throw RangeError("Invalid attack value."); this._attack = e } get release() { return this._release } set release(e) { if (u.validation && (isNaN(e = parseFloat(e)) || !(e >= 0 && e <= 1))) throw RangeError("Invalid release value."); this._release = e } get rawAttack() { return i.fromFloatTo7Bit(this._attack) } set rawAttack(e) { this._attack = i.from7bitToFloat(e) } get rawRelease() { return i.fromFloatTo7Bit(this._release) } set rawRelease(e) { this._release = i.from7bitToFloat(e) } get number() { return i.toNoteNumber(this.identifier) } getOffsetNumber(e = 0, t = 0) { return u.validation && (e = parseInt(e) || 0, t = parseInt(t) || 0), Math.min(Math.max(this.number + 12 * e + t, 0), 127) } } class i { static toNoteNumber(e, t = 0) { if (isNaN(t = void 0 == t ? 0 : parseInt(t))) throw RangeError("Invalid 'octaveOffset' value"); "string" != typeof e && (e = ""); let n = this.getNoteDetails(e); if (!n) throw TypeError("Invalid note identifier"); let s = (n.octave + 1 + t) * 12; if (s += ({ C: 0, D: 2, E: 4, F: 5, G: 7, A: 9, B: 11 })[n.name], n.accidental && (n.accidental.startsWith("b") ? s -= n.accidental.length : s += n.accidental.length), s < 0 || s > 127) throw RangeError("Invalid octaveOffset value"); return s } static getNoteDetails(e) { Number.isInteger(e) && (e = this.toNoteIdentifier(e)); let t = e.match(/^([CDEFGAB])(#{0,2}|b{0,2})(-?\d+)$/i); if (!t) throw TypeError("Invalid note identifier"); let n = t[1].toUpperCase(), s = parseInt(t[3]), a = t[2].toLowerCase(); a = "" === a ? void 0 : a; let i = { accidental: a, identifier: n + (a || "") + s, name: n, octave: s }; return i } static sanitizeChannels(e) { let t; if (this.validation) { if ("all" === e) t = ["all"]; else if ("none" === e) return [] } return (t = Array.isArray(e) ? e : [e]).indexOf("all") > -1 && (t = s.MIDI_CHANNEL_NUMBERS), t.map(function (e) { return parseInt(e) }).filter(function (e) { return e >= 1 && e <= 16 }) } static toTimestamp(e) { let t = !1, n = parseFloat(e); return !isNaN(n) && ("string" == typeof e && "+" === e.substring(0, 1) ? n >= 0 && (t = u.time + n) : n >= 0 && (t = n), t) } static guessNoteNumber(e, t) { t = parseInt(t) || 0; let n = !1; if (Number.isInteger(e) && e >= 0 && e <= 127) n = parseInt(e); else if (parseInt(e) >= 0 && 127 >= parseInt(e)) n = parseInt(e); else if ("string" == typeof e || e instanceof String) try { n = this.toNoteNumber(e.trim(), t) } catch (s) { return !1 } return n } static toNoteIdentifier(e, t) { if (isNaN(e = parseInt(e)) || e < 0 || e > 127) throw RangeError("Invalid note number"); if (isNaN(t = void 0 == t ? 0 : parseInt(t))) throw RangeError("Invalid octaveOffset value"); let n = Math.floor(e / 12 - 1) + t; return ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"][e % 12] + n.toString() } static buildNote(e, t = {}) { if (t.octaveOffset = parseInt(t.octaveOffset) || 0, e instanceof a) return e; let n = this.guessNoteNumber(e, t.octaveOffset); if (!1 === n) throw TypeError(`The input could not be parsed as a note (${e})`); return t.octaveOffset = void 0, new a(n, t) } static buildNoteArray(e, t = {}) { let n = []; return Array.isArray(e) || (e = [e]), e.forEach(e => { n.push(this.buildNote(e, t)) }), n } static from7bitToFloat(e) { return e === 1 / 0 && (e = 127), Math.min(Math.max((e = parseInt(e) || 0) / 127, 0), 1) } static fromFloatTo7Bit(e) { return e === 1 / 0 && (e = 1), Math.min(Math.max(Math.round(127 * (e = parseFloat(e) || 0)), 0), 127) } static fromMsbLsbToFloat(e, t = 0) { u.validation && (e = Math.min(Math.max(parseInt(e) || 0, 0), 127), t = Math.min(Math.max(parseInt(t) || 0, 0), 127)); let n = ((e << 7) + t) / 16383; return Math.min(Math.max(n, 0), 1) } static fromFloatToMsbLsb(e) { u.validation && (e = Math.min(Math.max(parseFloat(e) || 0, 0), 1)); let t = Math.round(16383 * e); return { msb: t >> 7, lsb: 127 & t } } static offsetNumber(e, t = 0, n = 0) { if (u.validation) { if (isNaN(e = parseInt(e))) throw Error("Invalid note number"); t = parseInt(t) || 0, n = parseInt(n) || 0 } return Math.min(Math.max(e + 12 * t + n, 0), 127) } static getPropertyByValue(e, t) { return Object.keys(e).find(n => e[n] === t) } static getCcNameByNumber(e) { return i.getPropertyByValue(s.MIDI_CONTROL_CHANGE_MESSAGES, e) } static getChannelModeByNumber(e) { if (!(e >= 120 && e <= 127)) return !1; for (let t in s.MIDI_CHANNEL_MODE_MESSAGES) if (s.MIDI_CHANNEL_MODE_MESSAGES.hasOwnProperty(t) && e === s.MIDI_CHANNEL_MODE_MESSAGES[t]) return t; return !1 } } class r extends t { constructor(e, t) { super(), this._output = e, this._number = t, this._octaveOffset = 0 } destroy() { this._output = null, this._number = null, this._octaveOffset = 0, this.removeListener() } send(e, t = { time: 0 }) { return this.output.send(e, t), this } sendKeyAftertouch(e, t, n = {}) { if (u.validation) { if (n.useRawValue && (n.rawValue = n.useRawValue), isNaN(parseFloat(t))) throw RangeError("Invalid key aftertouch value."); if (n.rawValue) { if (!(t >= 0 && t <= 127 && Number.isInteger(t))) throw RangeError("Key aftertouch raw value must be an integer between 0 and 127.") } else if (!(t >= 0 && t <= 1)) throw RangeError("Key aftertouch value must be a float between 0 and 1.") } n.rawValue || (t = i.fromFloatTo7Bit(t)); let a = u.octaveOffset + this.output.octaveOffset + this.octaveOffset; return Array.isArray(e) || (e = [e]), i.buildNoteArray(e).forEach(e => { this.send([(s.MIDI_CHANNEL_MESSAGES.keyaftertouch << 4) + (this.number - 1), e.getOffsetNumber(a), t], { time: i.toTimestamp(n.time) }) }), this } sendControlChange(e, t, n = {}) { if ("string" == typeof e && (e = s.MIDI_CONTROL_CHANGE_MESSAGES[e]), Array.isArray(t) || (t = [t]), u.validation) { if (void 0 === e) throw TypeError("Control change must be identified with a valid name or an integer between 0 and 127."); if (!Number.isInteger(e) || !(e >= 0 && e <= 127)) throw TypeError("Control change number must be an integer between 0 and 127."); if (2 === (t = t.map(e => { let t = Math.min(Math.max(parseInt(e), 0), 127); if (isNaN(t)) throw TypeError("Values must be integers between 0 and 127"); return t })).length && e >= 32) throw TypeError("To use a value array, the controller must be between 0 and 31") } return t.forEach((a, r) => { this.send([(s.MIDI_CHANNEL_MESSAGES.controlchange << 4) + (this.number - 1), e + 32 * r, t[r]], { time: i.toTimestamp(n.time) }) }), this } _selectNonRegisteredParameter(e, t = {}) { return this.sendControlChange(99, e[0], t), this.sendControlChange(98, e[1], t), this } _deselectRegisteredParameter(e = {}) { return this.sendControlChange(101, 127, e), this.sendControlChange(100, 127, e), this } _deselectNonRegisteredParameter(e = {}) { return this.sendControlChange(101, 127, e), this.sendControlChange(100, 127, e), this } _selectRegisteredParameter(e, t = {}) { return this.sendControlChange(101, e[0], t), this.sendControlChange(100, e[1], t), this } _setCurrentParameter(e, t = {}) { return e = [].concat(e), this.sendControlChange(6, e[0], t), e.length < 2 || this.sendControlChange(38, e[1], t), this } sendRpnDecrement(e, t = {}) { if (Array.isArray(e) || (e = s.MIDI_REGISTERED_PARAMETERS[e]), u.validation) { if (void 0 === e) throw TypeError("The specified registered parameter is invalid."); let n = !1; if (Object.getOwnPropertyNames(s.MIDI_REGISTERED_PARAMETERS).forEach(t => { s.MIDI_REGISTERED_PARAMETERS[t][0] === e[0] && s.MIDI_REGISTERED_PARAMETERS[t][1] === e[1] && (n = !0) }), !n) throw TypeError("The specified registered parameter is invalid.") } return this._selectRegisteredParameter(e, t), this.sendControlChange(97, 0, t), this._deselectRegisteredParameter(t), this } sendRpnIncrement(e, t = {}) { if (Array.isArray(e) || (e = s.MIDI_REGISTERED_PARAMETERS[e]), u.validation) { if (void 0 === e) throw TypeError("The specified registered parameter is invalid."); let n = !1; if (Object.getOwnPropertyNames(s.MIDI_REGISTERED_PARAMETERS).forEach(t => { s.MIDI_REGISTERED_PARAMETERS[t][0] === e[0] && s.MIDI_REGISTERED_PARAMETERS[t][1] === e[1] && (n = !0) }), !n) throw TypeError("The specified registered parameter is invalid.") } return this._selectRegisteredParameter(e, t), this.sendControlChange(96, 0, t), this._deselectRegisteredParameter(t), this } playNote(e, t = {}) { if (this.sendNoteOn(e, t), t.duration > 0 && isFinite(String(t.duration).trim() || NaN)) { let n = { time: (i.toTimestamp(t.time) || u.time) + t.duration, release: t.release, rawRelease: t.rawRelease }; this.sendNoteOff(e, n) } return this } sendNoteOff(e, t = {}) { if (u.validation) { if (void 0 != t.rawRelease && !(t.rawRelease >= 0 && t.rawRelease <= 127)) throw RangeError("The 'rawRelease' option must be an integer between 0 and 127"); if (void 0 != t.release && !(t.release >= 0 && t.release <= 1)) throw RangeError("The 'release' option must be an number between 0 and 1"); t.rawVelocity && (t.rawRelease = t.velocity, console.warn("The 'rawVelocity' option is deprecated. Use 'rawRelease' instead.")), t.velocity && (t.release = t.velocity, console.warn("The 'velocity' option is deprecated. Use 'attack' instead.")) } let n = 64; void 0 != t.rawRelease ? n = t.rawRelease : isNaN(t.release) || (n = Math.round(127 * t.release)); let a = u.octaveOffset + this.output.octaveOffset + this.octaveOffset; return i.buildNoteArray(e, { rawRelease: parseInt(n) }).forEach(e => { this.send([(s.MIDI_CHANNEL_MESSAGES.noteoff << 4) + (this.number - 1), e.getOffsetNumber(a), e.rawRelease], { time: i.toTimestamp(t.time) }) }), this } stopNote(e, t = {}) { return this.sendNoteOff(e, t) } sendNoteOn(e, t = {}) { if (u.validation) { if (void 0 != t.rawAttack && !(t.rawAttack >= 0 && t.rawAttack <= 127)) throw RangeError("The 'rawAttack' option must be an integer between 0 and 127"); if (void 0 != t.attack && !(t.attack >= 0 && t.attack <= 1)) throw RangeError("The 'attack' option must be an number between 0 and 1"); t.rawVelocity && (t.rawAttack = t.velocity, t.rawRelease = t.release, console.warn("The 'rawVelocity' option is deprecated. Use 'rawAttack' or 'rawRelease'.")), t.velocity && (t.attack = t.velocity, console.warn("The 'velocity' option is deprecated. Use 'attack' instead.")) } let n = 64; void 0 != t.rawAttack ? n = t.rawAttack : isNaN(t.attack) || (n = Math.round(127 * t.attack)); let a = u.octaveOffset + this.output.octaveOffset + this.octaveOffset; return i.buildNoteArray(e, { rawAttack: n }).forEach(e => { this.send([(s.MIDI_CHANNEL_MESSAGES.noteon << 4) + (this.number - 1), e.getOffsetNumber(a), e.rawAttack], { time: i.toTimestamp(t.time) }) }), this } sendChannelMode(e, t = 0, n = {}) { if ("string" == typeof e && (e = s.MIDI_CHANNEL_MODE_MESSAGES[e]), u.validation) { if (void 0 === e) throw TypeError("Invalid channel mode message name or number."); if (isNaN(e) || !(e >= 120 && e <= 127)) throw TypeError("Invalid channel mode message number."); if (isNaN(parseInt(t)) || t < 0 || t > 127) throw RangeError("Value must be an integer between 0 and 127.") } return this.send([(s.MIDI_CHANNEL_MESSAGES.controlchange << 4) + (this.number - 1), e, t], { time: i.toTimestamp(n.time) }), this } sendOmniMode(e, t = {}) { return void 0 === e || e ? this.sendChannelMode("omnimodeon", 0, t) : this.sendChannelMode("omnimodeoff", 0, t), this } sendChannelAftertouch(e, t = {}) { if (u.validation) { if (isNaN(parseFloat(e))) throw RangeError("Invalid channel aftertouch value."); if (t.rawValue) { if (!(e >= 0 && e <= 127 && Number.isInteger(e))) throw RangeError("Channel aftertouch raw value must be an integer between 0 and 127.") } else if (!(e >= 0 && e <= 1)) throw RangeError("Channel aftertouch value must be a float between 0 and 1.") } return this.send([(s.MIDI_CHANNEL_MESSAGES.channelaftertouch << 4) + (this.number - 1), Math.round(127 * e)], { time: i.toTimestamp(t.time) }), this } sendMasterTuning(e, t = {}) { if (e = parseFloat(e) || 0, u.validation && !(e > -65 && e < 64)) throw RangeError("The value must be a decimal number larger than -65 and smaller than 64."); let n = Math.floor(e) + 64, s = e - Math.floor(e), a = (s = Math.round((s + 1) / 2 * 16383)) >> 7 & 127, i = 127 & s; return this.sendRpnValue("channelcoarsetuning", n, t), this.sendRpnValue("channelfinetuning", [a, i], t), this } sendModulationRange(e, t, n = {}) { if (u.validation) { if (!Number.isInteger(e) || !(e >= 0 && e <= 127)) throw RangeError("The semitones value must be an integer between 0 and 127."); if (void 0 != t && (!Number.isInteger(t) || !(t >= 0 && t <= 127))) throw RangeError("If specified, the cents value must be an integer between 0 and 127.") } return t >= 0 && t <= 127 || (t = 0), this.sendRpnValue("modulationrange", [e, t], n), this } sendNrpnValue(e, t, n = {}) { if (t = [].concat(t), u.validation) { if (!Array.isArray(e) || !Number.isInteger(e[0]) || !Number.isInteger(e[1])) throw TypeError("The specified NRPN is invalid."); if (!(e[0] >= 0 && e[0] <= 127)) throw RangeError("The first byte of the NRPN must be between 0 and 127."); if (!(e[1] >= 0 && e[1] <= 127)) throw RangeError("The second byte of the NRPN must be between 0 and 127."); t.forEach(e => { if (!(e >= 0 && e <= 127)) throw RangeError("The data bytes of the NRPN must be between 0 and 127.") }) } return this._selectNonRegisteredParameter(e, n), this._setCurrentParameter(t, n), this._deselectNonRegisteredParameter(n), this } sendPitchBend(e, t = {}) { if (u.validation) { if (t.rawValue && Array.isArray(e)) { if (!(e[0] >= 0 && e[0] <= 127)) throw RangeError("The pitch bend MSB must be an integer between 0 and 127."); if (!(e[1] >= 0 && e[1] <= 127)) throw RangeError("The pitch bend LSB must be an integer between 0 and 127.") } else if (t.rawValue && !Array.isArray(e)) { if (!(e >= 0 && e <= 127)) throw RangeError("The pitch bend MSB must be an integer between 0 and 127.") } else { if (isNaN(e) || null === e) throw RangeError("Invalid pitch bend value."); if (!(e >= -1 && e <= 1)) throw RangeError("The pitch bend MSB must be an integer between 0 and 127.") } } let n = 0, a = 0; if (t.rawValue && Array.isArray(e)) n = e[0], a = e[1]; else if (t.rawValue && !Array.isArray(e)) n = e; else { let r = i.fromFloatToMsbLsb((e + 1) / 2); n = r.msb, a = r.lsb } return this.send([(s.MIDI_CHANNEL_MESSAGES.pitchbend << 4) + (this.number - 1), a, n], { time: i.toTimestamp(t.time) }), this } sendPitchBendRange(e, t, n = {}) { if (u.validation) { if (!Number.isInteger(e) || !(e >= 0 && e <= 127)) throw RangeError("The semitones value must be an integer between 0 and 127."); if (!Number.isInteger(t) || !(t >= 0 && t <= 127)) throw RangeError("The cents value must be an integer between 0 and 127.") } return this.sendRpnValue("pitchbendrange", [e, t], n), this } sendProgramChange(e, t = {}) { if (e = parseInt(e) || 0, u.validation && !(e >= 0 && e <= 127)) throw RangeError("The program number must be between 0 and 127."); return this.send([(s.MIDI_CHANNEL_MESSAGES.programchange << 4) + (this.number - 1), e], { time: i.toTimestamp(t.time) }), this } sendRpnValue(e, t, n = {}) { if (Array.isArray(e) || (e = s.MIDI_REGISTERED_PARAMETERS[e]), u.validation) { if (!Number.isInteger(e[0]) || !Number.isInteger(e[1])) throw TypeError("The specified NRPN is invalid."); if (!(e[0] >= 0 && e[0] <= 127)) throw RangeError("The first byte of the RPN must be between 0 and 127."); if (!(e[1] >= 0 && e[1] <= 127)) throw RangeError("The second byte of the RPN must be between 0 and 127.");[].concat(t).forEach(e => { if (!(e >= 0 && e <= 127)) throw RangeError("The data bytes of the RPN must be between 0 and 127.") }) } return this._selectRegisteredParameter(e, n), this._setCurrentParameter(t, n), this._deselectRegisteredParameter(n), this } sendTuningBank(e, t = {}) { if (u.validation && (!Number.isInteger(e) || !(e >= 0 && e <= 127))) throw RangeError("The tuning bank number must be between 0 and 127."); return this.sendRpnValue("tuningbank", e, t), this } sendTuningProgram(e, t = {}) { if (u.validation && (!Number.isInteger(e) || !(e >= 0 && e <= 127))) throw RangeError("The tuning program number must be between 0 and 127."); return this.sendRpnValue("tuningprogram", e, t), this } sendLocalControl(e, t = {}) { return e ? this.sendChannelMode("localcontrol", 127, t) : this.sendChannelMode("localcontrol", 0, t) } sendAllNotesOff(e = {}) { return this.sendChannelMode("allnotesoff", 0, e) } sendAllSoundOff(e = {}) { return this.sendChannelMode("allsoundoff", 0, e) } sendResetAllControllers(e = {}) { return this.sendChannelMode("resetallcontrollers", 0, e) } sendPolyphonicMode(e, t = {}) { return "mono" === e ? this.sendChannelMode("monomodeon", 0, t) : this.sendChannelMode("polymodeon", 0, t) } get octaveOffset() { return this._octaveOffset } set octaveOffset(e) { if (this.validation && isNaN(e = parseInt(e))) throw TypeError("The 'octaveOffset' property must be an integer."); this._octaveOffset = e } get output() { return this._output } get number() { return this._number } } class o extends t { constructor(e) { super(), this._midiOutput = e, this._octaveOffset = 0, this.channels = []; for (let t = 1; t <= 16; t++)this.channels[t] = new r(this, t); this._midiOutput.onstatechange = this._onStateChange.bind(this) } async destroy() { this.removeListener(), this.channels.forEach(e => e.destroy()), this.channels = [], this._midiOutput.onstatechange = null, await this.close(), this._midiOutput = null } _onStateChange(e) { let t = { timestamp: u.time }; "open" === e.port.connection ? (t.type = "opened", t.target = this, this.emit("opened", t)) : "closed" === e.port.connection && "connected" === e.port.state ? (t.type = "closed", t.target = this, this.emit("closed", t)) : "closed" === e.port.connection && "disconnected" === e.port.state ? (t.type = "disconnected", t.target = { connection: e.port.connection, id: e.port.id, manufacturer: e.port.manufacturer, name: e.port.name, state: e.port.state, type: e.port.type }, this.emit("disconnected", t)) : "pending" === e.port.connection && "disconnected" === e.port.state || console.warn("This statechange event was not caught:", e.port.connection, e.port.state) } async open() { try { return await this._midiOutput.open(), Promise.resolve(this) } catch (e) { return Promise.reject(e) } } async close() { this._midiOutput ? await this._midiOutput.close() : await Promise.resolve() } send(e, t = { time: 0 }, n) { if (e instanceof c && (e = u.isNode ? e.data : e.rawData), e instanceof Uint8Array && u.isNode && (e = Array.from(e)), u.validation) { if (Array.isArray(e) || e instanceof Uint8Array || (e = [e], Array.isArray(t) && (e = e.concat(t)), t = n ? { time: n } : { time: 0 }), !(parseInt(e[0]) >= 128 && 255 >= parseInt(e[0]))) throw RangeError("The first byte (status) must be an integer between 128 and 255."); e.slice(1).forEach(e => { if (!((e = parseInt(e)) >= 0 && e <= 255)) throw RangeError("Data bytes must be integers between 0 and 255.") }), t || (t = { time: 0 }) } return this._midiOutput.send(e, i.toTimestamp(t.time)), this } sendSysex(e, t = [], n = {}) { if (e = [].concat(e), t instanceof Uint8Array) { let a = new Uint8Array(1 + e.length + t.length + 1); a[0] = s.MIDI_SYSTEM_MESSAGES.sysex, a.set(Uint8Array.from(e), 1), a.set(t, 1 + e.length), a[a.length - 1] = s.MIDI_SYSTEM_MESSAGES.sysexend, this.send(a, { time: n.time }) } else { let i = e.concat(t, s.MIDI_SYSTEM_MESSAGES.sysexend); this.send([s.MIDI_SYSTEM_MESSAGES.sysex].concat(i), { time: n.time }) } return this } clear() { return this._midiOutput.clear ? this._midiOutput.clear() : u.validation && console.warn("The 'clear()' method has not yet been implemented in your environment."), this } sendTimecodeQuarterFrame(e, t = {}) { if (u.validation && (isNaN(e = parseInt(e)) || !(e >= 0 && e <= 127))) throw RangeError("The value must be an integer between 0 and 127."); return this.send([s.MIDI_SYSTEM_MESSAGES.timecode, e], { time: t.time }), this } sendSongPosition(e = 0, t = {}) { var n = (e = Math.floor(e) || 0) >> 7 & 127, a = 127 & e; return this.send([s.MIDI_SYSTEM_MESSAGES.songposition, n, a], { time: t.time }), this } sendSongSelect(e = 0, t = {}) { if (u.validation && (isNaN(e = parseInt(e)) || !(e >= 0 && e <= 127))) throw RangeError("The program value must be between 0 and 127"); return this.send([s.MIDI_SYSTEM_MESSAGES.songselect, e], { time: t.time }), this } sendTuneRequest(e = {}) { return this.send([s.MIDI_SYSTEM_MESSAGES.tunerequest], { time: e.time }), this } sendClock(e = {}) { return this.send([s.MIDI_SYSTEM_MESSAGES.clock], { time: e.time }), this } sendStart(e = {}) { return this.send([s.MIDI_SYSTEM_MESSAGES.start], { time: e.time }), this } sendContinue(e = {}) { return this.send([s.MIDI_SYSTEM_MESSAGES.continue], { time: e.time }), this } sendStop(e = {}) { return this.send([s.MIDI_SYSTEM_MESSAGES.stop], { time: e.time }), this } sendActiveSensing(e = {}) { return this.send([s.MIDI_SYSTEM_MESSAGES.activesensing], { time: e.time }), this } sendReset(e = {}) { return this.send([s.MIDI_SYSTEM_MESSAGES.reset], { time: e.time }), this } sendTuningRequest(e = {}) { return u.validation && console.warn("The sendTuningRequest() method has been deprecated. Use sendTuningRequest() instead."), this.sendTuneRequest(e) } sendKeyAftertouch(e, t, n = {}) { return void 0 == n.channels && (n.channels = s.MIDI_CHANNEL_NUMBERS), i.sanitizeChannels(n.channels).forEach(s => { this.channels[s].sendKeyAftertouch(e, t, n) }), this } sendControlChange(e, t, n = {}, a = {}) { if (u.validation && (Array.isArray(n) || Number.isInteger(n) || "all" === n)) { let r = n; (n = a).channels = r, "all" === n.channels && (n.channels = s.MIDI_CHANNEL_NUMBERS) } return void 0 == n.channels && (n.channels = s.MIDI_CHANNEL_NUMBERS), i.sanitizeChannels(n.channels).forEach(s => { this.channels[s].sendControlChange(e, t, n) }), this } sendPitchBendRange(e = 0, t = 0, n = {}) { return void 0 == n.channels && (n.channels = s.MIDI_CHANNEL_NUMBERS), i.sanitizeChannels(n.channels).forEach(s => { this.channels[s].sendPitchBendRange(e, t, n) }), this } setPitchBendRange(e = 0, t = 0, n = "all", a = {}) { return u.validation && (console.warn("The setPitchBendRange() method is deprecated. Use sendPitchBendRange() instead."), a.channels = n, "all" === a.channels && (a.channels = s.MIDI_CHANNEL_NUMBERS)), this.sendPitchBendRange(e, t, a) } sendRpnValue(e, t, n = {}) { return void 0 == n.channels && (n.channels = s.MIDI_CHANNEL_NUMBERS), i.sanitizeChannels(n.channels).forEach(s => { this.channels[s].sendRpnValue(e, t, n) }), this } setRegisteredParameter(e, t = [], n = "all", a = {}) { return u.validation && (console.warn("The setRegisteredParameter() method is deprecated. Use sendRpnValue() instead."), a.channels = n, "all" === a.channels && (a.channels = s.MIDI_CHANNEL_NUMBERS)), this.sendRpnValue(e, t, a) } sendChannelAftertouch(e, t = {}, n = {}) { if (u.validation && (Array.isArray(t) || Number.isInteger(t) || "all" === t)) { let a = t; (t = n).channels = a, "all" === t.channels && (t.channels = s.MIDI_CHANNEL_NUMBERS) } return void 0 == t.channels && (t.channels = s.MIDI_CHANNEL_NUMBERS), i.sanitizeChannels(t.channels).forEach(n => { this.channels[n].sendChannelAftertouch(e, t) }), this } sendPitchBend(e, t = {}, n = {}) { if (u.validation && (Array.isArray(t) || Number.isInteger(t) || "all" === t)) { let a = t; (t = n).channels = a, "all" === t.channels && (t.channels = s.MIDI_CHANNEL_NUMBERS) } return void 0 == t.channels && (t.channels = s.MIDI_CHANNEL_NUMBERS), i.sanitizeChannels(t.channels).forEach(n => { this.channels[n].sendPitchBend(e, t) }), this } sendProgramChange(e = 0, t = {}, n = {}) { if (u.validation && (Array.isArray(t) || Number.isInteger(t) || "all" === t)) { let a = t; (t = n).channels = a, "all" === t.channels && (t.channels = s.MIDI_CHANNEL_NUMBERS) } return void 0 == t.channels && (t.channels = s.MIDI_CHANNEL_NUMBERS), i.sanitizeChannels(t.channels).forEach(n => { this.channels[n].sendProgramChange(e, t) }), this } sendModulationRange(e, t, n = {}) { return void 0 == n.channels && (n.channels = s.MIDI_CHANNEL_NUMBERS), i.sanitizeChannels(n.channels).forEach(s => { this.channels[s].sendModulationRange(e, t, n) }), this } setModulationRange(e = 0, t = 0, n = "all", a = {}) { return u.validation && (console.warn("The setModulationRange() method is deprecated. Use sendModulationRange() instead."), a.channels = n, "all" === a.channels && (a.channels = s.MIDI_CHANNEL_NUMBERS)), this.sendModulationRange(e, t, a) } sendMasterTuning(e, t = {}) { return void 0 == t.channels && (t.channels = s.MIDI_CHANNEL_NUMBERS), i.sanitizeChannels(t.channels).forEach(n => { this.channels[n].sendMasterTuning(e, t) }), this } setMasterTuning(e, t = {}, n = {}) { return u.validation && (console.warn("The setMasterTuning() method is deprecated. Use sendMasterTuning() instead."), n.channels = t, "all" === n.channels && (n.channels = s.MIDI_CHANNEL_NUMBERS)), this.sendMasterTuning(e, n) } sendTuningProgram(e, t = {}) { return void 0 == t.channels && (t.channels = s.MIDI_CHANNEL_NUMBERS), i.sanitizeChannels(t.channels).forEach(n => { this.channels[n].sendTuningProgram(e, t) }), this } setTuningProgram(e, t = "all", n = {}) { return u.validation && (console.warn("The setTuningProgram() method is deprecated. Use sendTuningProgram() instead."), n.channels = t, "all" === n.channels && (n.channels = s.MIDI_CHANNEL_NUMBERS)), this.sendTuningProgram(e, n) } sendTuningBank(e = 0, t = {}) { return void 0 == t.channels && (t.channels = s.MIDI_CHANNEL_NUMBERS), i.sanitizeChannels(t.channels).forEach(n => { this.channels[n].sendTuningBank(e, t) }), this } setTuningBank(e, t = "all", n = {}) { return u.validation && (console.warn("The setTuningBank() method is deprecated. Use sendTuningBank() instead."), n.channels = t, "all" === n.channels && (n.channels = s.MIDI_CHANNEL_NUMBERS)), this.sendTuningBank(e, n) } sendChannelMode(e, t = 0, n = {}, a = {}) { if (u.validation && (Array.isArray(n) || Number.isInteger(n) || "all" === n)) { let r = n; (n = a).channels = r, "all" === n.channels && (n.channels = s.MIDI_CHANNEL_NUMBERS) } return void 0 == n.channels && (n.channels = s.MIDI_CHANNEL_NUMBERS), i.sanitizeChannels(n.channels).forEach(s => { this.channels[s].sendChannelMode(e, t, n) }), this } sendAllSoundOff(e = {}) { return void 0 == e.channels && (e.channels = s.MIDI_CHANNEL_NUMBERS), i.sanitizeChannels(e.channels).forEach(t => { this.channels[t].sendAllSoundOff(e) }), this } sendAllNotesOff(e = {}) { return void 0 == e.channels && (e.channels = s.MIDI_CHANNEL_NUMBERS), i.sanitizeChannels(e.channels).forEach(t => { this.channels[t].sendAllNotesOff(e) }), this } sendResetAllControllers(e = {}, t = {}) { if (u.validation && (Array.isArray(e) || Number.isInteger(e) || "all" === e)) { let n = e; (e = t).channels = n, "all" === e.channels && (e.channels = s.MIDI_CHANNEL_NUMBERS) } return void 0 == e.channels && (e.channels = s.MIDI_CHANNEL_NUMBERS), i.sanitizeChannels(e.channels).forEach(t => { this.channels[t].sendResetAllControllers(e) }), this } sendPolyphonicMode(e, t = {}, n = {}) { if (u.validation && (Array.isArray(t) || Number.isInteger(t) || "all" === t)) { let a = t; (t = n).channels = a, "all" === t.channels && (t.channels = s.MIDI_CHANNEL_NUMBERS) } return void 0 == t.channels && (t.channels = s.MIDI_CHANNEL_NUMBERS), i.sanitizeChannels(t.channels).forEach(n => { this.channels[n].sendPolyphonicMode(e, t) }), this } sendLocalControl(e, t = {}, n = {}) { if (u.validation && (Array.isArray(t) || Number.isInteger(t) || "all" === t)) { let a = t; (t = n).channels = a, "all" === t.channels && (t.channels = s.MIDI_CHANNEL_NUMBERS) } return void 0 == t.channels && (t.channels = s.MIDI_CHANNEL_NUMBERS), i.sanitizeChannels(t.channels).forEach(n => { this.channels[n].sendLocalControl(e, t) }), this } sendOmniMode(e, t = {}, n = {}) { if (u.validation && (Array.isArray(t) || Number.isInteger(t) || "all" === t)) { let a = t; (t = n).channels = a, "all" === t.channels && (t.channels = s.MIDI_CHANNEL_NUMBERS) } return void 0 == t.channels && (t.channels = s.MIDI_CHANNEL_NUMBERS), i.sanitizeChannels(t.channels).forEach(n => { this.channels[n].sendOmniMode(e, t) }), this } sendNrpnValue(e, t, n = {}) { return void 0 == n.channels && (n.channels = s.MIDI_CHANNEL_NUMBERS), i.sanitizeChannels(n.channels).forEach(s => { this.channels[s].sendNrpnValue(e, t, n) }), this } setNonRegisteredParameter(e, t = [], n = "all", a = {}) { return u.validation && (console.warn("The setNonRegisteredParameter() method is deprecated. Use sendNrpnValue() instead."), a.channels = n, "all" === a.channels && (a.channels = s.MIDI_CHANNEL_NUMBERS)), this.sendNrpnValue(e, t, a) } sendRpnIncrement(e, t = {}) { return void 0 == t.channels && (t.channels = s.MIDI_CHANNEL_NUMBERS), i.sanitizeChannels(t.channels).forEach(n => { this.channels[n].sendRpnIncrement(e, t) }), this } incrementRegisteredParameter(e, t = "all", n = {}) { return u.validation && (console.warn("The incrementRegisteredParameter() method is deprecated. Use sendRpnIncrement() instead."), n.channels = t, "all" === n.channels && (n.channels = s.MIDI_CHANNEL_NUMBERS)), this.sendRpnIncrement(e, n) } sendRpnDecrement(e, t = {}) { return void 0 == t.channels && (t.channels = s.MIDI_CHANNEL_NUMBERS), i.sanitizeChannels(t.channels).forEach(n => { this.channels[n].sendRpnDecrement(e, t) }), this } decrementRegisteredParameter(e, t = "all", n = {}) { return u.validation && (console.warn("The decrementRegisteredParameter() method is deprecated. Use sendRpnDecrement() instead."), n.channels = t, "all" === n.channels && (n.channels = s.MIDI_CHANNEL_NUMBERS)), this.sendRpnDecrement(e, n) } sendNoteOff(e, t = {}, n = {}) { if (u.validation && (Array.isArray(t) || Number.isInteger(t) || "all" === t)) { let a = t; (t = n).channels = a, "all" === t.channels && (t.channels = s.MIDI_CHANNEL_NUMBERS) } return void 0 == t.channels && (t.channels = s.MIDI_CHANNEL_NUMBERS), i.sanitizeChannels(t.channels).forEach(n => { this.channels[n].sendNoteOff(e, t) }), this } stopNote(e, t) { return this.sendNoteOff(e, t) } playNote(e, t = {}, n = {}) { if (u.validation && (t.rawVelocity && console.warn("The 'rawVelocity' option is deprecated. Use 'rawAttack' instead."), t.velocity && console.warn("The 'velocity' option is deprecated. Use 'velocity' instead."), Array.isArray(t) || Number.isInteger(t) || "all" === t)) { let a = t; (t = n).channels = a, "all" === t.channels && (t.channels = s.MIDI_CHANNEL_NUMBERS) } return void 0 == t.channels && (t.channels = s.MIDI_CHANNEL_NUMBERS), i.sanitizeChannels(t.channels).forEach(n => { this.channels[n].playNote(e, t) }), this } sendNoteOn(e, t = {}, n = {}) { if (u.validation && (Array.isArray(t) || Number.isInteger(t) || "all" === t)) { let a = t; (t = n).channels = a, "all" === t.channels && (t.channels = s.MIDI_CHANNEL_NUMBERS) } return void 0 == t.channels && (t.channels = s.MIDI_CHANNEL_NUMBERS), i.sanitizeChannels(t.channels).forEach(n => { this.channels[n].sendNoteOn(e, t) }), this } get name() { return this._midiOutput.name } get id() { return this._midiOutput.id } get connection() { return this._midiOutput.connection } get manufacturer() { return this._midiOutput.manufacturer } get state() { return this._midiOutput.state } get type() { return this._midiOutput.type } get octaveOffset() { return this._octaveOffset } set octaveOffset(e) { if (this.validation && isNaN(e = parseInt(e))) throw TypeError("The 'octaveOffset' property must be an integer."); this._octaveOffset = e } } class l { constructor(e = [], t = {}) { this.destinations = [], this.types = [...Object.keys(s.MIDI_SYSTEM_MESSAGES), ...Object.keys(s.MIDI_CHANNEL_MESSAGES)], this.channels = s.MIDI_CHANNEL_NUMBERS, this.suspended = !1, Array.isArray(e) || (e = [e]), t.types && !Array.isArray(t.types) && (t.types = [t.types]), t.channels && !Array.isArray(t.channels) && (t.channels = [t.channels]), u.validation && (e.forEach(e => { if (!(e instanceof o)) throw TypeError("Destinations must be of type 'Output'.") }), void 0 !== t.types && t.types.forEach(e => { if (!s.MIDI_SYSTEM_MESSAGES.hasOwnProperty(e) && !s.MIDI_CHANNEL_MESSAGES.hasOwnProperty(e)) throw TypeError("Type must be a valid message type.") }), void 0 !== t.channels && t.channels.forEach(e => { if (!s.MIDI_CHANNEL_NUMBERS.includes(e)) throw TypeError("MIDI channel must be between 1 and 16.") })), this.destinations = e, t.types && (this.types = t.types), t.channels && (this.channels = t.channels) } forward(e) { !this.suspended && this.types.includes(e.type) && (!e.channel || this.channels.includes(e.channel)) && this.destinations.forEach(t => { (!u.validation || t instanceof o) && t.send(e) }) } } class h extends t { constructor(e, t) { super(), this._input = e, this._number = t, this._octaveOffset = 0, this._nrpnBuffer = [], this._rpnBuffer = [], this.parameterNumberEventsEnabled = !0, this.notesState = Array(128).fill(!1) } destroy() { this._input = null, this._number = null, this._octaveOffset = 0, this._nrpnBuffer = [], this.notesState = Array(128).fill(!1), this.parameterNumberEventsEnabled = !1, this.removeListener() } _processMidiMessageEvent(e) { let t = Object.assign({}, e); t.target = this, t.type = "midimessage", this.emit(t.type, t), this._parseEventForStandardMessages(t) } _parseEventForStandardMessages(e) { let t = Object.assign({}, e); t.type = t.message.type || "unknownmidimessage"; let n = e.message.dataBytes[0], s = e.message.dataBytes[1]; if ("noteoff" === t.type || "noteon" === t.type && 0 === s) this.notesState[n] = !1, t.note = new a(i.offsetNumber(n, this.octaveOffset + this.input.octaveOffset + u.octaveOffset), { rawAttack: 0, rawRelease: s }), t.value = i.from7bitToFloat(s), t.rawValue = s, t.velocity = t.note.release, t.rawVelocity = t.note.rawRelease; else if ("noteon" === t.type) this.notesState[n] = !0, t.note = new a(i.offsetNumber(n, this.octaveOffset + this.input.octaveOffset + u.octaveOffset), { rawAttack: s }), t.value = i.from7bitToFloat(s), t.rawValue = s, t.velocity = t.note.attack, t.rawVelocity = t.note.rawAttack; else if ("keyaftertouch" === t.type) t.identifier = i.toNoteIdentifier(n, u.octaveOffset + this.input.octaveOffset + this.octaveOffset), t.key = i.toNoteNumber(t.identifier), t.rawKey = n, t.value = i.from7bitToFloat(s), t.rawValue = s, t.note = new a(i.offsetNumber(n, this.octaveOffset + this.input.octaveOffset + u.octaveOffset)); else if ("controlchange" === t.type) { t.controller = { number: n, name: i.getCcNameByNumber(n) }, t.subtype = t.controller.name || "controller" + n, t.value = i.from7bitToFloat(s), t.rawValue = s; let r = Object.assign({}, t); r.type = `${t.type}-controller${n}`, delete r.subtype, this.emit(r.type, r), t.message.dataBytes[0] >= 120 && this._parseChannelModeMessage(t), this.parameterNumberEventsEnabled && this._isRpnOrNrpnController(t.message.dataBytes[0]) && this._parseEventForParameterNumber(t) } else "programchange" === t.type ? (t.value = n + 1, t.rawValue = n) : "channelaftertouch" === t.type ? (t.value = i.from7bitToFloat(n), t.rawValue = n) : "pitchbend" === t.type ? (t.value = ((s << 7) + n - 8192) / 8192, t.rawValue = (s << 7) + n) : t.type = "unknownmessage"; this.emit(t.type, t) } _parseChannelModeMessage(e) { let t = Object.assign({}, e); t.type = t.controller.name, "localcontrol" === t.type && (t.value = 127 === t.message.data[2]), "omnimodeon" === t.type ? (t.type = "omnimode", t.value = !0) : "omnimodeoff" === t.type && (t.type = "omnimode", t.value = !1), "monomodeon" === t.type ? (t.type = "monomode", t.value = !0) : "polymodeon" === t.type && (t.type = "monomode", t.value = !1), this.emit(t.type, t) } _parseEventForParameterNumber(e) { let t = e.message.dataBytes[0], n = e.message.dataBytes[1], a = s.MIDI_CONTROL_CHANGE_MESSAGES; t === a.nonregisteredparameterfine || t === a.registeredparameterfine ? (this._nrpnBuffer = [], this._rpnBuffer = [], t === a.nonregisteredparameterfine ? this._nrpnBuffer = [e.message] : 127 !== n && (this._rpnBuffer = [e.message])) : t === a.nonregisteredparametercoarse || t === a.registeredparametercoarse ? t === a.nonregisteredparametercoarse ? (this._rpnBuffer = [], 1 === this._nrpnBuffer.length ? this._nrpnBuffer.push(e.message) : this._nrpnBuffer = []) : (this._nrpnBuffer = [], 1 === this._rpnBuffer.length && 127 !== n ? this._rpnBuffer.push(e.message) : this._rpnBuffer = []) : (t === a.dataentrycoarse || t === a.dataentryfine || t === a.databuttonincrement || t === a.databuttondecrement) && (2 === this._rpnBuffer.length ? this._dispatchParameterNumberEvent("rpn", this._rpnBuffer[0].dataBytes[1], this._rpnBuffer[1].dataBytes[1], e) : 2 === this._nrpnBuffer.length ? this._dispatchParameterNumberEvent("nrpn", this._nrpnBuffer[0].dataBytes[1], this._nrpnBuffer[1].dataBytes[1], e) : (this._nrpnBuffer = [], this._rpnBuffer = [])) } _isRpnOrNrpnController(e) { return e === s.MIDI_CONTROL_CHANGE_MESSAGES.dataentrycoarse || e === s.MIDI_CONTROL_CHANGE_MESSAGES.dataentryfine || e === s.MIDI_CONTROL_CHANGE_MESSAGES.databuttonincrement || e === s.MIDI_CONTROL_CHANGE_MESSAGES.databuttondecrement || e === s.MIDI_CONTROL_CHANGE_MESSAGES.nonregisteredparametercoarse || e === s.MIDI_CONTROL_CHANGE_MESSAGES.nonregisteredparameterfine || e === s.MIDI_CONTROL_CHANGE_MESSAGES.registeredparametercoarse || e === s.MIDI_CONTROL_CHANGE_MESSAGES.registeredparameterfine } _dispatchParameterNumberEvent(e, t, n, a) { e = "nrpn" === e ? "nrpn" : "rpn"; let r = { target: a.target, timestamp: a.timestamp, parameterMsb: t, parameterLsb: n, value: i.from7bitToFloat(a.message.dataBytes[1]), rawValue: a.message.dataBytes[1] }; "rpn" === e ? r.parameter = Object.keys(s.MIDI_REGISTERED_PARAMETERS).find(e => s.MIDI_REGISTERED_PARAMETERS[e][0] === t && s.MIDI_REGISTERED_PARAMETERS[e][1] === n) : r.parameter = (t << 7) + n; let o = i.getPropertyByValue(s.MIDI_CONTROL_CHANGE_MESSAGES, a.message.dataBytes[0]); r.type = `${e}-${o}`, this.emit(r.type, r), r.type = e, r.subtype = o, this.emit(r.type, r) } getChannelModeByNumber(e) { return u.validation && (console.warn("The 'getChannelModeByNumber()' method has been moved to the 'Utilities' class."), e = Math.floor(e)), i.getChannelModeByNumber(e) } getCcNameByNumber(e) { if (u.validation && (console.warn("The 'getCcNameByNumber()' method has been moved to the 'Utilities' class."), !((e = parseInt(e)) >= 0 && e <= 127))) throw RangeError("Invalid control change number."); return i.getCcNameByNumber(e) } getNoteState(e) { e instanceof a && (e = e.identifier); let t = i.guessNoteNumber(e, u.octaveOffset + this.input.octaveOffset + this.octaveOffset); return this.notesState[t] } get octaveOffset() { return this._octaveOffset } set octaveOffset(e) { if (this.validation && isNaN(e = parseInt(e))) throw TypeError("The 'octaveOffset' property must be an integer."); this._octaveOffset = e } get input() { return this._input } get number() { return this._number } get nrpnEventsEnabled() { return this.parameterNumberEventsEnabled } set nrpnEventsEnabled(e) { this.validation && (e = !!e), this.parameterNumberEventsEnabled = e } static get EVENTS() { return ["noteoff", "controlchange", "noteon", "keyaftertouch", "programchange", "channelaftertouch", "pitchbend", "allnotesoff", "allsoundoff", "localcontrol", "monomode", "omnimode", "resetallcontrollers", "nrpn", "nrpn-dataentrycoarse", "nrpn-dataentryfine", "nrpn-databuttonincrement", "nrpn-databuttondecrement", "rpn", "rpn-dataentrycoarse", "rpn-dataentryfine", "rpn-databuttonincrement", "rpn-databuttondecrement"] } } class c { constructor(e) { this.rawData = e, this.data = Array.from(this.rawData), this.statusByte = this.rawData[0], this.rawDataBytes = this.rawData.slice(1), this.dataBytes = this.data.slice(1), this.isChannelMessage = !1, this.isSystemMessage = !1, this.command = void 0, this.channel = void 0, this.manufacturerId = void 0, this.type = void 0, this.statusByte < 240 ? (this.isChannelMessage = !0, this.command = this.statusByte >> 4, this.channel = (15 & this.statusByte) + 1) : (this.isSystemMessage = !0, this.command = this.statusByte), this.isChannelMessage ? this.type = i.getPropertyByValue(s.MIDI_CHANNEL_MESSAGES, this.command) : this.isSystemMessage && (this.type = i.getPropertyByValue(s.MIDI_SYSTEM_MESSAGES, this.command)), this.statusByte === s.MIDI_SYSTEM_MESSAGES.sysex && (0 === this.dataBytes[0] ? (this.manufacturerId = this.dataBytes.slice(0, 3), this.dataBytes = this.dataBytes.slice(3, this.rawDataBytes.length - 1), this.rawDataBytes = this.rawDataBytes.slice(3, this.rawDataBytes.length - 1)) : (this.manufacturerId = [this.dataBytes[0]], this.dataBytes = this.dataBytes.slice(1, this.dataBytes.length - 1), this.rawDataBytes = this.rawDataBytes.slice(1, this.rawDataBytes.length - 1))) } } class d extends t { constructor(e) { super(), this._midiInput = e, this._octaveOffset = 0, this.channels = []; for (let t = 1; t <= 16; t++)this.channels[t] = new h(this, t); this._forwarders = [], this._midiInput.onstatechange = this._onStateChange.bind(this), this._midiInput.onmidimessage = this._onMidiMessage.bind(this) } async destroy() { this.removeListener(), this.channels.forEach(e => e.destroy()), this.channels = [], this._forwarders = [], this._midiInput && (this._midiInput.onstatechange = null, this._midiInput.onmidimessage = null), await this.close(), this._midiInput = null } _onStateChange(e) { let t = { timestamp: u.time, target: this }; "open" === e.port.connection ? (t.type = "opened", this.emit("opened", t)) : "closed" === e.port.connection && "connected" === e.port.state ? (t.type = "closed", this.emit("closed", t)) : "closed" === e.port.connection && "disconnected" === e.port.state ? (t.type = "disconnected", t.target = { connection: e.port.connection, id: e.port.id, manufacturer: e.port.manufacturer, name: e.port.name, state: e.port.state, type: e.port.type }, this.emit("disconnected", t)) : "pending" === e.port.connection && "disconnected" === e.port.state || console.warn("This statechange event was not caught: ", e.port.connection, e.port.state) } _onMidiMessage(e) { let t = new c(e.data), n = { target: this, message: t, timestamp: e.timeStamp, type: "midimessage", data: t.data, rawData: t.data, statusByte: t.data[0], dataBytes: t.dataBytes }; this.emit("midimessage", n), t.isSystemMessage ? this._parseEvent(n) : t.isChannelMessage && this.channels[t.channel]._processMidiMessageEvent(n), this._forwarders.forEach(e => e.forward(t)) } _parseEvent(e) { let t = Object.assign({}, e); t.type = t.message.type || "unknownmidimessage", "songselect" === t.type && (t.song = e.data[1] + 1), this.emit(t.type, t) } async open() { try { await this._midiInput.open() } catch (e) { return Promise.reject(e) } return Promise.resolve(this) } async close() { if (!this._midiInput) return Promise.resolve(this); try { await this._midiInput.close() } catch (e) { return Promise.reject(e) } return Promise.resolve(this) } getChannelModeByNumber() { u.validation && console.warn("The 'getChannelModeByNumber()' method has been moved to the 'Utilities' class.") } addListener(e, t, n = {}) { if (u.validation && "function" == typeof n) { let a = void 0 != t ? [].concat(t) : void 0; t = n, n = { channels: a } } if (!h.EVENTS.includes(e)) return super.addListener(e, t, n); { void 0 === n.channels && (n.channels = s.MIDI_CHANNEL_NUMBERS); let r = []; return i.sanitizeChannels(n.channels).forEach(s => { r.push(this.channels[s].addListener(e, t, n)) }), r } } addOneTimeListener(e, t, n = {}) { return n.remaining = 1, this.addListener(e, t, n) } on(e, t, n, s) { return this.addListener(e, t, n, s) } hasListener(e, t, n = {}) { if (u.validation && "function" == typeof n) { let a = [].concat(t); t = n, n = { channels: a } } return h.EVENTS.includes(e) ? (void 0 === n.channels && (n.channels = s.MIDI_CHANNEL_NUMBERS), i.sanitizeChannels(n.channels).every(n => this.channels[n].hasListener(e, t))) : super.hasListener(e, t) } removeListener(e, t, n = {}) { if (u.validation && "function" == typeof n) { let a = [].concat(t); t = n, n = { channels: a } } if (void 0 === n.channels && (n.channels = s.MIDI_CHANNEL_NUMBERS), void 0 == e) return i.sanitizeChannels(n.channels).forEach(e => { this.channels[e] && this.channels[e].removeListener() }), super.removeListener(); h.EVENTS.includes(e) ? i.sanitizeChannels(n.channels).forEach(s => { this.channels[s].removeListener(e, t, n) }) : super.removeListener(e, t, n) } addForwarder(e, t = {}) { let n; return n = e instanceof l ? e : new l(e, t), this._forwarders.push(n), n } removeForwarder(e) { this._forwarders = this._forwarders.filter(t => t !== e) } hasForwarder(e) { return this._forwarders.includes(e) } get name() { return this._midiInput.name } get id() { return this._midiInput.id } get connection() { return this._midiInput.connection } get manufacturer() { return this._midiInput.manufacturer } get octaveOffset() { return this._octaveOffset } set octaveOffset(e) { if (this.validation && isNaN(e = parseInt(e))) throw TypeError("The 'octaveOffset' property must be an integer."); this._octaveOffset = e } get state() { return this._midiInput.state } get type() { return this._midiInput.type } get nrpnEventsEnabled() { return u.validation && console.warn("The 'nrpnEventsEnabled' property has been moved to the 'InputChannel' class."), !1 } } let u = new class e extends t { constructor() { super(), this.defaults = { note: { attack: i.from7bitToFloat(64), release: i.from7bitToFloat(64), duration: 1 / 0 } }, this.interface = null, this.validation = !0, this._inputs = [], this._disconnectedInputs = [], this._outputs = [], this._disconnectedOutputs = [], this._stateChangeQueue = [], this._octaveOffset = 0 } async enable(e = {}, t = !1) { if (this.validation = !1 !== e.validation, this.validation && ("function" == typeof e && (e = { callback: e, sysex: t }), t && (e.sysex = !0)), this.enabled) return "function" == typeof e.callback && e.callback(), Promise.resolve(); let n = { timestamp: this.time, target: this, type: "error", error: void 0 }, s = { timestamp: this.time, target: this, type: "midiaccessgranted" }, a = { timestamp: this.time, target: this, type: "enabled" }; try { this.interface = await navigator.requestMIDIAccess({ sysex: e.sysex, software: e.software }) } catch (i) { return n.error = i, this.emit("error", n), "function" == typeof e.callback && e.callback(i), Promise.reject(i) } this.emit("midiaccessgranted", s), this.interface.onstatechange = this._onInterfaceStateChange.bind(this); try { await this._updateInputsAndOutputs() } catch (r) { return n.error = r, this.emit("error", n), "function" == typeof e.callback && e.callback(r), Promise.reject(r) } return this.emit("enabled", a), "function" == typeof e.callback && e.callback(), Promise.resolve(this) } async disable() { return this._destroyInputsAndOutputs().then(() => { "function" == typeof navigator.close && navigator.close(), this.interface && (this.interface.onstatechange = void 0), this.interface = null; let e = { timestamp: this.time, target: this, type: "disabled" }; this.emit("disabled", e), this.removeListener() }) } getInputById(e) { if (this.validation) { if (!this.enabled) throw Error("WebMidi is not enabled."); if (!e) return !1 } for (let t = 0; t < this.inputs.length; t++)if (this.inputs[t].id === e.toString()) return this.inputs[t]; return !1 } getInputByName(e) { if (this.validation) { if (!this.enabled) throw Error("WebMidi is not enabled."); if (!e) return !1; e = e.toString() } for (let t = 0; t < this.inputs.length; t++)if (~this.inputs[t].name.indexOf(e)) return this.inputs[t]; return !1 } getOutputByName(e) { if (this.validation) { if (!this.enabled) throw Error("WebMidi is not enabled."); if (!e) return !1; e = e.toString() } for (let t = 0; t < this.outputs.length; t++)if (~this.outputs[t].name.indexOf(e)) return this.outputs[t]; return !1 } getOutputById(e) { if (this.validation) { if (!this.enabled) throw Error("WebMidi is not enabled."); if (!e) return !1 } for (let t = 0; t < this.outputs.length; t++)if (this.outputs[t].id === e.toString()) return this.outputs[t]; return !1 } noteNameToNumber(e) { return this.validation && console.warn("The noteNameToNumber() method is deprecated. Use Utilities.toNoteNumber() instead."), i.toNoteNumber(e, this.octaveOffset) } getOctave(e) { return this.validation && (console.warn("The getOctave()is deprecated. Use Utilities.getNoteDetails() instead"), e = parseInt(e)), !isNaN(e) && e >= 0 && e <= 127 && i.getNoteDetails(i.offsetNumber(e, this.octaveOffset)).octave } sanitizeChannels(e) { return this.validation && console.warn("The sanitizeChannels() method has been moved to the utilities class."), i.sanitizeChannels(e) } toMIDIChannels(e) { return this.validation && console.warn("The toMIDIChannels() method has been deprecated. Use Utilities.sanitizeChannels() instead."), i.sanitizeChannels(e) } guessNoteNumber(e) { return this.validation && console.warn("The guessNoteNumber() method has been deprecated. Use Utilities.guessNoteNumber() instead."), i.guessNoteNumber(e, this.octaveOffset) } getValidNoteArray(e, t = {}) { return this.validation && console.warn("The getValidNoteArray() method has been moved to the Utilities.buildNoteArray()"), i.buildNoteArray(e, t) } convertToTimestamp(e) { return this.validation && console.warn("The convertToTimestamp() method has been moved to Utilities.toTimestamp()."), i.toTimestamp(e) } async _destroyInputsAndOutputs() { let e = []; return this.inputs.forEach(t => e.push(t.destroy())), this.outputs.forEach(t => e.push(t.destroy())), Promise.all(e).then(() => { this._inputs = [], this._outputs = [] }) } _onInterfaceStateChange(e) { this._updateInputsAndOutputs(); let t = { timestamp: e.timeStamp, type: e.port.state }; "connected" === e.port.state && "open" === e.port.connection ? ("output" === e.port.type ? (t.port = this.getOutputById(e.port.id), t.target = t.port) : "input" === e.port.type && (t.port = this.getInputById(e.port.id), t.target = t.port), this.emit(e.port.state, t)) : "disconnected" === e.port.state && "pending" === e.port.connection && (t.port = { connection: "closed", id: e.port.id, manufacturer: e.port.manufacturer, name: e.port.name, state: e.port.state, type: e.port.type }, t.target = t.port, this.emit(e.port.state, t)) } async _updateInputsAndOutputs() { return Promise.all([this._updateInputs(), this._updateOutputs()]) } async _updateInputs() { if (!this.interface) return; for (let e = this._inputs.length - 1; e >= 0; e--) { let t = this._inputs[e], n = Array.from(this.interface.inputs.values()); n.find(e => e === t._midiInput) || (this._disconnectedInputs.push(t), this._inputs.splice(e, 1)) } let s = []; return this.interface.inputs.forEach(e => { if (!this._inputs.find(t => t._midiInput === e)) { let t = this._disconnectedInputs.find(t => t._midiInput === e); t || (t = new d(e)), this._inputs.push(t), s.push(t.open()) } }), Promise.all(s) } async _updateOutputs() { if (!this.interface) return; for (let e = this._outputs.length - 1; e >= 0; e--) { let t = this._outputs[e], n = Array.from(this.interface.outputs.values()); n.find(e => e === t._midiOutput) || (this._disconnectedOutputs.push(t), this._outputs.splice(e, 1)) } let s = []; return this.interface.outputs.forEach(e => { if (!this._outputs.find(t => t._midiOutput === e)) { let t = this._disconnectedOutputs.find(t => t._midiOutput === e); t || (t = new o(e)), this._outputs.push(t), s.push(t.open()) } }), Promise.all(s) } get enabled() { return null !== this.interface } get inputs() { return this._inputs } get isNode() { return "[object process]" === Object.prototype.toString.call("undefined" != typeof process ? process : 0) } get isBrowser() { return "undefined" != typeof window && void 0 !== window.document } get octaveOffset() { return this._octaveOffset } set octaveOffset(e) { if (this.validation && isNaN(e = parseInt(e))) throw TypeError("The 'octaveOffset' property must be an integer."); this._octaveOffset = e } get outputs() { return this._outputs } get supported() { return "undefined" != typeof navigator && navigator.requestMIDIAccess } get sysexEnabled() { return !!(this.interface && this.interface.sysexEnabled) } get time() { return performance.now() } get version() { return "3.0.0-alpha.26" } get CHANNEL_EVENTS() { return this.validation && console.warn("The CHANNEL_EVENTS enum has been moved to InputChannel.EVENTS."), h.EVENTS } get MIDI_SYSTEM_MESSAGES() { return this.validation && console.warn("The MIDI_SYSTEM_MESSAGES enum has been moved to Enumerations.MIDI_SYSTEM_MESSAGES."), s.MIDI_SYSTEM_MESSAGES } get MIDI_CHANNEL_MODE_MESSAGES() { return this.validation && console.warn("The MIDI_CHANNEL_MODE_MESSAGES enum has been moved to Enumerations.MIDI_CHANNEL_MODE_MESSAGES."), s.MIDI_CHANNEL_MODE_MESSAGES } get MIDI_CONTROL_CHANGE_MESSAGES() { return this.validation && console.warn("The MIDI_CONTROL_CHANGE_MESSAGES enum has been moved to Enumerations.MIDI_CONTROL_CHANGE_MESSAGES."), s.MIDI_CONTROL_CHANGE_MESSAGES } get MIDI_REGISTERED_PARAMETER() { return this.validation && console.warn("The MIDI_REGISTERED_PARAMETER enum has been moved to Enumerations.MIDI_REGISTERED_PARAMETERS."), this.MIDI_REGISTERED_PARAMETERS } get NOTES() { return this.validation && console.warn("The NOTES enum has been deprecated."), ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"] } }; u.constructor = null, e.Enumerations = s, e.Forwarder = l, e.Message = c, e.Note = a, e.Utilities = i, e.WebMidi = u }(this.window = this.window || {});